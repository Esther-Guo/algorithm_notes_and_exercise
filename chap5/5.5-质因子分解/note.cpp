// n=1的情况需要根据题意进行特判

// 可以使用factor结构体存储质因子, 可证明对于int型数据，fac数组最多开到10，素数表开到10^5
struct factor{
    int x, cnt; // 质因子及个数
}fac[10];

// 另外可证明对于任何一个正整数n，如果存在[2,n]范围内质因子，要么所有质因子均小于sqrt(n)，
// 要么有且只有一个质因子大于n。因此可以按照如下思路分解质因子:O(sqrt(n))

// 枚举1~sqrt(n)范围内所有质因子p（即遍历质数表），判断是否为n的质因子
if (n%prime[i] == 0) { // prime[i]是质因子
    fac[num].x = prime[i]; // 记录该因子并初始化cnt
    fac[num].cnt = 0;
    while (n%prime[i] == 0){
        fac[num].cnt++;
        n /= prime[i];
    }
    num++; // 准备记录下一个质因子
}

// 如果p不是质因子则直接跳过
// 上述过程结束后n仍大于1，则说明存在一个大于sqrt(n)的质因子
if (n!=1){
    fac[num].x = n;
    fac[num++].cnt = 1; // 注意num要加1
}


// 另：欲求正整数n的因子个数（包括质因子），则应先对n做质因子分解，假设各质因子出现次数
// 分别为e1,e2,...,ek. 则总因子个数为(e1+1)*(e2+1)*...*(ek+1). (每个质因子都可以选择
// 自己出现0~ei次)